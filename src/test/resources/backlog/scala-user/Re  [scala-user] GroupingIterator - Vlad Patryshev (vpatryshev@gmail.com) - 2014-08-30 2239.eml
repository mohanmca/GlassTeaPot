Delivered-To: gnani.swami@gmail.com
Received: by 10.25.170.147 with SMTP id t141csp323515lfe;
        Sat, 30 Aug 2014 07:39:51 -0700 (PDT)
Return-Path: <scala-user+bncBD775REH6MMRBNGEQ6QAKGQEAY72WII@googlegroups.com>
Received-SPF: pass (google.com: domain of scala-user+bncBD775REH6MMRBNGEQ6QAKGQEAY72WII@googlegroups.com designates 10.140.101.165 as permitted sender) client-ip=10.140.101.165
Authentication-Results: mr.google.com;
       spf=pass (google.com: domain of scala-user+bncBD775REH6MMRBNGEQ6QAKGQEAY72WII@googlegroups.com designates 10.140.101.165 as permitted sender) smtp.mail=scala-user+bncBD775REH6MMRBNGEQ6QAKGQEAY72WII@googlegroups.com;
       dkim=pass header.i=@googlegroups.com
X-Received: from mr.google.com ([10.140.101.165])
        by 10.140.101.165 with SMTP id u34mr81664qge.15.1409409591546 (num_hops = 1);
        Sat, 30 Aug 2014 07:39:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlegroups.com; s=20120806;
        h=mime-version:in-reply-to:references:from:date:message-id:subject:to
         :cc:x-original-sender:x-original-authentication-results:precedence
         :mailing-list:list-id:list-post:list-help:list-archive:sender
         :list-subscribe:list-unsubscribe:content-type;
        bh=F//TQSWe+Hl+Ws1V9Qza9SqnQibWHvqZy6Vbf77CknE=;
        b=rofr4AvVAVa0/QvvkBVkyKHQVPF4jyD4Pq8zr6f90uFBQ0q2p+QRqaIxp8WxQbaltQ
         dcwvsY4hAbu3Hub4aoGcOe+UdRjHJxDPTLyA0nMcrSlHCCXEkCbZvPvR7OXB9cKCSPvw
         1F/akrqBshNDbXuL9+x6Ufwr5etk1UQsPA09Cx11peV5SyNBoOaj0QlMhPP40ZrlmILS
         DjUkkuknPxiE8m7afDTZtTpGLWu2+sDgPvQI6j/Fn+fRl1q0G0/vYJtpWd2m+Phztfo3
         drS1AJMzW5Sz+xYS9QAQh5f0MnqNDT6IJhDnT3jiwlPeBmmzoEiRLj57BEWA8jIiGgk4
         ZRkw==
X-Received: by 10.140.101.165 with SMTP id u34mr13690qge.15.1409409591167;
        Sat, 30 Aug 2014 07:39:51 -0700 (PDT)
X-BeenThere: scala-user@googlegroups.com
Received: by 10.140.34.206 with SMTP id l72ls1452491qgl.46.gmail; Sat, 30 Aug
 2014 07:39:48 -0700 (PDT)
X-Received: by 10.236.104.199 with SMTP id i47mr7604989yhg.33.1409409588532;
        Sat, 30 Aug 2014 07:39:48 -0700 (PDT)
Received: from mail-qg0-x22b.google.com (mail-qg0-x22b.google.com [2607:f8b0:400d:c04::22b])
        by gmr-mx.google.com with ESMTPS id i4si681436qcm.0.2014.08.30.07.39.48
        for <scala-user@googlegroups.com>
        (version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
        Sat, 30 Aug 2014 07:39:48 -0700 (PDT)
Received-SPF: pass (google.com: domain of vpatryshev@gmail.com designates 2607:f8b0:400d:c04::22b as permitted sender) client-ip=2607:f8b0:400d:c04::22b;
Received: by mail-qg0-f43.google.com with SMTP id f51so3458502qge.2
        for <scala-user@googlegroups.com>; Sat, 30 Aug 2014 07:39:48 -0700 (PDT)
X-Received: by 10.140.22.19 with SMTP id 19mr26402417qgm.18.1409409588300;
 Sat, 30 Aug 2014 07:39:48 -0700 (PDT)
MIME-Version: 1.0
Received: by 10.224.39.139 with HTTP; Sat, 30 Aug 2014 07:39:28 -0700 (PDT)
In-Reply-To: <CAC_CU1iw00mYRW76wPrFjD-SxjO_3dkur0w8QeGk81juzey0BQ@mail.gmail.com>
References: <49637b93-b350-447f-bc41-1c8b11b033d7@googlegroups.com>
 <CAA_Y42wAi7=R5aFrEPb=yKF8BuxcgZg66EJUMA1qxGt+e8dHjg@mail.gmail.com>
 <CAPaMnL4QSwP42cnQATGVVXcO-WBWbj_Eut=HwEZ2Xgm+624zOw@mail.gmail.com>
 <CAC_CU1hFV7Ypswx8ecP3haE4v=3YOqeSUuZoEAfWJefbr2QXoA@mail.gmail.com>
 <CAFhNTo-L2wg3Pwnvvi1TfWbCi7SAMDzjbOuo6U8C54Zp0qTQXw@mail.gmail.com>
 <CAP_xLa049f5KkBQrCKNE5X1LyB6GT42FfEC42zzrmRAXgOHLCg@mail.gmail.com> <CAC_CU1iw00mYRW76wPrFjD-SxjO_3dkur0w8QeGk81juzey0BQ@mail.gmail.com>
From: Vlad Patryshev <vpatryshev@gmail.com>
Date: Sat, 30 Aug 2014 07:39:28 -0700
Message-ID: <CAFhNTo_OqpnVee95QtBQyfDCQMqvxBHj54guoyq4CsFBM5U_-Q@mail.gmail.com>
Subject: Re: [scala-user] GroupingIterator
To: Pedro Larroy <pedro.larroy.lists@gmail.com>
Cc: Rex Kerr <ichoran@gmail.com>, Som Snytt <som.snytt@gmail.com>, atomly <atomly@gmail.com>, 
	scala-user <scala-user@googlegroups.com>
X-Original-Sender: vpatryshev@gmail.com
X-Original-Authentication-Results: gmr-mx.google.com;       spf=pass
 (google.com: domain of vpatryshev@gmail.com designates 2607:f8b0:400d:c04::22b
 as permitted sender) smtp.mail=vpatryshev@gmail.com;       dkim=pass
 header.i=@gmail.com;       dmarc=pass (p=NONE dis=NONE) header.from=gmail.com
Precedence: list
Mailing-list: list scala-user@googlegroups.com; contact scala-user+owners@googlegroups.com
List-ID: <scala-user.googlegroups.com>
X-Google-Group-Id: 163218044152
List-Post: <http://groups.google.com/group/scala-user/post>, <mailto:scala-user@googlegroups.com>
List-Help: <http://groups.google.com/support/>, <mailto:scala-user+help@googlegroups.com>
List-Archive: <http://groups.google.com/group/scala-user
Sender: scala-user@googlegroups.com
List-Subscribe: <http://groups.google.com/group/scala-user/subscribe>, <mailto:scala-user+subscribe@googlegroups.com>
List-Unsubscribe: <mailto:googlegroups-manage+163218044152+unsubscribe@googlegroups.com>,
 <http://groups.google.com/group/scala-user/subscribe>
Content-Type: multipart/alternative; boundary=001a11c14f7eda93330501d9bdbd

--001a11c14f7eda93330501d9bdbd
Content-Type: text/plain; charset=UTF-8

Or consider using scalaz...

Thanks,
-Vlad


On Sat, Aug 30, 2014 at 6:41 AM, Pedro Larroy <pedro.larroy.lists@gmail.com>
wrote:

> Maybe we should create a github repository with these kind of utility
> functions?
>
>
> On Sat, Aug 30, 2014 at 1:17 AM, Rex Kerr <ichoran@gmail.com> wrote:
>
>> And I have in my library an implementation that is reasonably efficient
>> and is an enrichment and returns the original collection type (not an
>> iterator):
>>
>>   class GroupedWhileCollections[A, C, D[C]](ca: C)(implicit c2i: C =>
>> Iterable[A], cbf: CanBuildFrom[C,C,D[C]], cbfi: CanBuildFrom[C,A,C]) {
>>     def groupedWhile(p: (A,A) => Boolean): D[C] = {
>>       val it = c2i(ca).iterator
>>       val cca = cbf()
>>       if (!it.hasNext) cca.result
>>       else {
>>         val as = cbfi()
>>         var olda = it.next
>>         as += olda
>>         while (it.hasNext) {
>>           val a = it.next
>>           if (p(olda,a)) as += a
>>           else { cca += as.result; as.clear; as += a }
>>           olda = a
>>         }
>>         cca += as.result
>>       }
>>       cca.result
>>     }
>>   }
>>   implicit def collections_can_groupWhile[A, C[A]](ca: C[A])(implicit
>> c2i: C[A] => Iterable[A], cbf: CanBuildFrom[C[A],C[A],C[C[A]]], cbfi:
>> CanBuildFrom[C[A],A,C[A]]) =
>>     new GroupedWhileCollections[A,C[A],C](ca)(c2i,cbf,cbfi)
>>
>> You can do strings also with an appropriate CBF:
>>
>>   val vector_string_builder = new CanBuildFrom[String, String,
>> Vector[String]] {
>>     def apply() = Vector.newBuilder[String]
>>     def apply(from: String) = this.apply()
>>   }
>>   implicit def strings_can_groupedWhile(s: String)(implicit c2i: String
>> => Iterable[Char], cbfi: CanBuildFrom[String,Char,String]) =
>>     new GroupedWhileCollections[Char,String,Vector](s)(c2i,
>> vector_string_builder, cbfi)
>>
>> But I think that, despite this being generally useful (as evidenced by
>> how many different people have their own implementations), the collections
>> are pretty much frozen for now.  So the thing to do is to enjoy (and
>> possible share) our own implementations.
>>
>>   --Rex
>>
>>
>>
>> On Fri, Aug 29, 2014 at 3:24 PM, Vlad Patryshev <vpatryshev@gmail.com>
>> wrote:
>>
>>> I have in my library an implementation that is not very efficient, but
>>> is ok as a prototype:
>>>
>>>   /**
>>>
>>>    * Grouping a list by a binary relationship, splitting it into
>>> segments where neighbors satisfy p
>>>
>>>    * @param xs the list to split
>>>
>>>    * @param p the predicate (T,T) => Boolean
>>>
>>>    * @tparam T whatever the type of list elements is
>>>
>>>    * @return list of groups, List[List[T] ]
>>>
>>>    */
>>>
>>>   def groupByRelationship[T](p: (T,T) => Boolean)(xs: Traversable[T]) = {
>>>
>>>     val (seg,acc) = ((List[T](),List[List[T]]()) /: xs) {
>>>
>>>       case ((y::ys, a), x) if p(y,x) => (x ::y ::ys, a)
>>>
>>>       case (   (ys, a), x)           => (x::Nil, ys.reverse::a)
>>>
>>>     }
>>>
>>>     (seg.reverse::acc).reverse drop 1
>>>
>>>   }
>>>
>>>
>>> Thanks,
>>> -Vlad
>>>
>>>
>>> On Fri, Aug 29, 2014 at 3:10 PM, Pedro Larroy <
>>> pedro.larroy.lists@gmail.com> wrote:
>>>
>>>> Som: exactly, we have found this idea quite useful, to group items
>>>> according to a predicate that refers to the items being grouped. Would
>>>> there be interest in adding it to the library?
>>>>
>>>>
>>>> On Fri, Aug 29, 2014 at 10:44 PM, Som Snytt <som.snytt@gmail.com>
>>>> wrote:
>>>>
>>>>> Iterator.GroupedIterator bills itself as "flexible," but not this
>>>>> flexible.
>>>>>
>>>>> scala> (1 to 10).toIterator slideBy ((i: Int, is: Seq[Int]) => is.sum
>>>>> + i <= 10)
>>>>> res6: Iterator[IndexedSeq[Int]] = non-empty iterator
>>>>>
>>>>> scala> res6.mkString(",")
>>>>> res7: String = Vector(1, 2, 3,
>>>>> 4),Vector(5),Vector(6),Vector(7),Vector(8),Vector(9),Vector(10)
>>>>>
>>>>> It just needs an optional stepping predicate.
>>>>>
>>>>>
>>>>> On Fri, Aug 29, 2014 at 9:43 AM, atomly <atomly@gmail.com> wrote:
>>>>>
>>>>>> I'm a little confused... This functionality wouldn't be satisfied by
>>>>>> Iterable.groupBy or Iterable.partition?
>>>>>>
>>>>>> Are you saying there are potentially more than two groups and it
>>>>>> would start a new group each time it returned false?
>>>>>>
>>>>>> :: atomly ::
>>>>>>
>>>>>> [ atomly@atomly.com : www.atomly.com  : http://blog.atomly.com/ ...
>>>>>> [ atomiq records : new york city : +1.347.692.8661 ...
>>>>>> [ e-mail atomly-news-subscribe@atomly.com for atomly info and
>>>>>> updates ...
>>>>>>
>>>>>>
>>>>>> On Thu, Aug 28, 2014 at 12:05 PM, Pedro Larroy <
>>>>>> pedro.larroy.lists@gmail.com> wrote:
>>>>>>
>>>>>>> Hi
>>>>>>>
>>>>>>> would it be interesting to include a grouping iterator given a
>>>>>>> predicate and previous elements to get an iterable of seq given an iterator?
>>>>>>>
>>>>>>>
>>>>>>> The code would be something like the following one.
>>>>>>>
>>>>>>>
>>>>>>> Regards.
>>>>>>>
>>>>>>> Pedro.
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>     import scala.collection.mutable.ArrayBuffer
>>>>>>>
>>>>>>>     object GroupingIterator {
>>>>>>>
>>>>>>>       /**
>>>>>>>        * Create a new GroupingIterator with a grouping predicate.
>>>>>>>        *
>>>>>>>        * @param it The original iterator
>>>>>>>        * @param p Predicate controlling the grouping
>>>>>>>        * @tparam A Type of elements iterated
>>>>>>>        * @return A new GroupingIterator
>>>>>>>        */
>>>>>>>       def apply[A](it: Iterator[A])(p: (A, IndexedSeq[A]) =>
>>>>>>> Boolean): GroupingIterator[A] =
>>>>>>>         new GroupingIterator(it)(p)
>>>>>>>     }
>>>>>>>
>>>>>>>     /**
>>>>>>>      * Group elements in sequences of contiguous elements that
>>>>>>> satisfy a predicate. The predicate
>>>>>>>      * tests each single potential next element of the group with
>>>>>>> the help of the elements grouped so far.
>>>>>>>      * If it returns true, the potential next element is added to
>>>>>>> the group, otherwise
>>>>>>>      * a new group is started with the potential next element as
>>>>>>> first element
>>>>>>>      *
>>>>>>>      * @param self The original iterator
>>>>>>>      * @param p Predicate controlling the grouping
>>>>>>>      * @tparam A Type of elements iterated
>>>>>>>      */
>>>>>>>     class GroupingIterator[+A](self: Iterator[A])(p: (A,
>>>>>>> IndexedSeq[A]) => Boolean) extends Iterator[IndexedSeq[A]] {
>>>>>>>
>>>>>>>       private[this] val source = self.buffered
>>>>>>>       private[this] val buffer: ArrayBuffer[A] = ArrayBuffer()
>>>>>>>
>>>>>>>       def hasNext: Boolean = source.hasNext
>>>>>>>
>>>>>>>       def next(): IndexedSeq[A] = {
>>>>>>>         if (hasNext)
>>>>>>>           nextGroup()
>>>>>>>         else
>>>>>>>           Iterator.empty.next()
>>>>>>>       }
>>>>>>>
>>>>>>>       private[this] def nextGroup(): IndexedSeq[A] = {
>>>>>>>         assert(source.hasNext)
>>>>>>>
>>>>>>>         buffer.clear()
>>>>>>>         buffer += source.next
>>>>>>>
>>>>>>>         while (source.hasNext && p(source.head, buffer)) {
>>>>>>>           buffer += source.next
>>>>>>>         }
>>>>>>>
>>>>>>>         buffer.toIndexedSeq
>>>>>>>       }
>>>>>>>     }
>>>>>>>
>>>>>>> --
>>>>>>> You received this message because you are subscribed to the Google
>>>>>>> Groups "scala-user" group.
>>>>>>> To unsubscribe from this group and stop receiving emails from it,
>>>>>>> send an email to scala-user+unsubscribe@googlegroups.com.
>>>>>>> For more options, visit https://groups.google.com/d/optout.
>>>>>>>
>>>>>>
>>>>>>  --
>>>>>> You received this message because you are subscribed to the Google
>>>>>> Groups "scala-user" group.
>>>>>> To unsubscribe from this group and stop receiving emails from it,
>>>>>> send an email to scala-user+unsubscribe@googlegroups.com.
>>>>>> For more options, visit https://groups.google.com/d/optout.
>>>>>>
>>>>>
>>>>>
>>>>  --
>>>> You received this message because you are subscribed to the Google
>>>> Groups "scala-user" group.
>>>> To unsubscribe from this group and stop receiving emails from it, send
>>>> an email to scala-user+unsubscribe@googlegroups.com.
>>>> For more options, visit https://groups.google.com/d/optout.
>>>>
>>>
>>>  --
>>> You received this message because you are subscribed to the Google
>>> Groups "scala-user" group.
>>> To unsubscribe from this group and stop receiving emails from it, send
>>> an email to scala-user+unsubscribe@googlegroups.com.
>>> For more options, visit https://groups.google.com/d/optout.
>>>
>>
>>
>

-- 
You received this message because you are subscribed to the Google Groups "scala-user" group.
To unsubscribe from this group and stop receiving emails from it, send an email to scala-user+unsubscribe@googlegroups.com.
For more options, visit https://groups.google.com/d/optout.

--001a11c14f7eda93330501d9bdbd
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr">Or consider using scalaz...</div><div class=3D"gmail_extra=
"><br clear=3D"all"><div>Thanks,<br>-Vlad</div>
<br><br><div class=3D"gmail_quote">On Sat, Aug 30, 2014 at 6:41 AM, Pedro L=
arroy <span dir=3D"ltr">&lt;<a href=3D"mailto:pedro.larroy.lists@gmail.com"=
 target=3D"_blank">pedro.larroy.lists@gmail.com</a>&gt;</span> wrote:<br><b=
lockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px =
#ccc solid;padding-left:1ex">

<div dir=3D"ltr">Maybe we should create a github repository with these kind=
 of utility functions?</div><div class=3D"HOEnZb"><div class=3D"h5"><div cl=
ass=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Sat, Aug 30, 2014=
 at 1:17 AM, Rex Kerr <span dir=3D"ltr">&lt;<a href=3D"mailto:ichoran@gmail=
.com" target=3D"_blank">ichoran@gmail.com</a>&gt;</span> wrote:<br>


<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex"><div dir=3D"ltr"><div><div><div>And I have i=
n my library an implementation that is reasonably efficient and is an enric=
hment and returns the original collection type (not an iterator):<br>


<br><span style=3D"font-family:courier new,monospace"><font size=3D"1">=C2=
=A0 class GroupedWhileCollections[A, C, D[C]](ca: C)(implicit c2i: C =3D&gt=
; Iterable[A], cbf: CanBuildFrom[C,C,D[C]], cbfi: CanBuildFrom[C,A,C]) {<br=
>
=C2=A0=C2=A0=C2=A0 def groupedWhile(p: (A,A) =3D&gt; Boolean): D[C] =3D {<b=
r>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 val it =3D c2i(ca).iterator<br>=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0 val cca =3D cbf()<br>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 i=
f (!it.hasNext) cca.result<br>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 else {<br>=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 val as =3D cbfi()<br>=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 var olda =3D it.next<br>



=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 as +=3D olda<br>=C2=A0=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0 while (it.hasNext) {<br>=C2=A0=C2=A0=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 val a =3D it.next<br>=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 if (p(olda,a)) as +=3D a<br>=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 else { cca +=3D as.result; as=
.clear; as +=3D a }<br>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=
=A0 olda =3D a<br>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 }<br>=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 cca +=3D as.result<br>



=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 }<br>=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 cca.resu=
lt<br>=C2=A0=C2=A0=C2=A0 }<br>=C2=A0 }<br>=C2=A0 implicit def collections_c=
an_groupWhile[A, C[A]](ca: C[A])(implicit c2i: C[A] =3D&gt; Iterable[A], cb=
f: CanBuildFrom[C[A],C[A],C[C[A]]], cbfi: CanBuildFrom[C[A],A,C[A]]) =3D <b=
r>



=C2=A0=C2=A0=C2=A0 new GroupedWhileCollections[A,C[A],C](ca)(c2i,cbf,cbfi)<=
br></font></span><br></div>You can do strings also with an appropriate CBF:=
<br><br><span style=3D"font-family:courier new,monospace"><font size=3D"1">=
=C2=A0 val vector_string_builder =3D new CanBuildFrom[String, String, Vecto=
r[String]] {<br>



=C2=A0=C2=A0=C2=A0 def apply() =3D Vector.newBuilder[String]<br>=C2=A0=C2=
=A0=C2=A0 def apply(from: String) =3D this.apply()<br>=C2=A0 }<br>=C2=A0 im=
plicit def strings_can_groupedWhile(s: String)(implicit c2i: String =3D&gt;=
 Iterable[Char], cbfi: CanBuildFrom[String,Char,String]) =3D<br>



=C2=A0=C2=A0=C2=A0 new GroupedWhileCollections[Char,String,Vector](s)(c2i, =
vector_string_builder, cbfi)<br></font></span><br></div>But I think that, d=
espite this being generally useful (as evidenced by how many different peop=
le have their own implementations), the collections are pretty much frozen =
for now.=C2=A0 So the thing to do is to enjoy (and possible share) our own =
implementations.<span><font color=3D"#888888"><br>



<br></font></span></div><span><font color=3D"#888888">=C2=A0 --Rex<br><br> =
</font></span></div><div class=3D"gmail_extra"><br><br><div class=3D"gmail_=
quote"><div>On Fri, Aug 29, 2014 at 3:24 PM, Vlad Patryshev <span dir=3D"lt=
r">&lt;<a href=3D"mailto:vpatryshev@gmail.com" target=3D"_blank">vpatryshev=
@gmail.com</a>&gt;</span> wrote:<br>



</div><div><div><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8e=
x;border-left:1px #ccc solid;padding-left:1ex"><div dir=3D"ltr">I have in m=
y library an implementation that is not very efficient, but is ok as a prot=
otype:<div>


<div><div>
<p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 /**<br></font></=
p><p><font face=3D"courier new, monospace" size=3D"1">=C2=A0=C2=A0 * Groupi=
ng a list by a binary relationship, splitting it into segments where neighb=
ors satisfy p</font></p>





<p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0* @param x=
s the list to split</font></p><p><font face=3D"courier new, monospace" size=
=3D"1">=C2=A0 =C2=A0* @param p the predicate (T,T) =3D&gt; Boolean</font></=
p><p>

<font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0* @tparam T w=
hatever the type of list elements is</font></p><p><font face=3D"courier new=
, monospace" size=3D"1">=C2=A0 =C2=A0* @return list of groups, List[List[T]=
 ]</font></p><p>

<font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0*/</font></p>=
<p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 def groupByRelat=
ionship[T](p: (T,T) =3D&gt; Boolean)(xs: Traversable[T]) =3D {</font></p><p=
><font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0 val (seg,ac=
c) =3D ((List[T](),List[List[T]]()) /: xs) {</font></p>





<p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0 =C2=A0 ca=
se ((y::ys, a), x) if p(y,x) =3D&gt; (x ::y ::ys, a)</font></p><p><font fac=
e=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0 =C2=A0 case ( =C2=A0 =
(ys, a), x) =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =3D&gt; (x::Nil, ys.reverse:=
:a)</font></p>





<p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0 }</font><=
/p><p><font face=3D"courier new, monospace" size=3D"1">=C2=A0 =C2=A0 (seg.r=
everse::acc).reverse drop 1</font></p><p><font face=3D"courier new, monospa=
ce" size=3D"1">=C2=A0 }</font></p>





</div></div></div><div><br></div></div><div class=3D"gmail_extra"><br clear=
=3D"all"><div>Thanks,<br>-Vlad</div><div><div>
<br><br><div class=3D"gmail_quote">On Fri, Aug 29, 2014 at 3:10 PM, Pedro L=
arroy <span dir=3D"ltr">&lt;<a href=3D"mailto:pedro.larroy.lists@gmail.com"=
 target=3D"_blank">pedro.larroy.lists@gmail.com</a>&gt;</span> wrote:<br><b=
lockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px =
#ccc solid;padding-left:1ex">





<div dir=3D"ltr">Som: exactly, we have found this idea quite useful, to gro=
up items according to a predicate that refers to the items being grouped. W=
ould there be interest in adding it to the library?</div><div>

<div><div class=3D"gmail_extra">
<br><br><div class=3D"gmail_quote">On Fri, Aug 29, 2014 at 10:44 PM, Som Sn=
ytt <span dir=3D"ltr">&lt;<a href=3D"mailto:som.snytt@gmail.com" target=3D"=
_blank">som.snytt@gmail.com</a>&gt;</span> wrote:<br><blockquote class=3D"g=
mail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
eft:1ex">






<div dir=3D"ltr"><div><div><div>Iterator.GroupedIterator bills itself as &q=
uot;flexible,&quot; but not this flexible.<br><br></div><span style=3D"font=
-family:courier new,monospace">scala&gt; (1 to 10).toIterator slideBy ((i: =
Int, is: Seq[Int]) =3D&gt; is.sum + i &lt;=3D 10) <br>







res6: Iterator[IndexedSeq[Int]] =3D non-empty iterator<br><br>scala&gt; res=
6.mkString(&quot;,&quot;)<br>res7: String =3D Vector(1, 2, 3, 4),Vector(5),=
Vector(6),Vector(7),Vector(8),Vector(9),Vector(10)</span><br><br></div></di=
v>







<div>It just needs an optional stepping predicate.<br></div></div><div><div=
><div class=3D"gmail_extra"><br><br><div class=3D"gmail_quote">On Fri, Aug =
29, 2014 at 9:43 AM, atomly <span dir=3D"ltr">&lt;<a href=3D"mailto:atomly@=
gmail.com" target=3D"_blank">atomly@gmail.com</a>&gt;</span> wrote:<br>







<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex"><div dir=3D"ltr">I&#39;m a little confused..=
. This functionality wouldn&#39;t be satisfied by Iterable.groupBy or Itera=
ble.partition?<div>







<br></div><div>Are you saying there are potentially more than two groups an=
d it would start a new group each time it returned false?</div>

</div><div class=3D"gmail_extra"><br clear=3D"all"><div>:: atomly ::<br><br=
>[ <a href=3D"mailto:atomly@atomly.com" target=3D"_blank">atomly@atomly.com=
</a> : <a href=3D"http://www.atomly.com" target=3D"_blank">www.atomly.com</=
a>=C2=A0 : <a href=3D"http://blog.atomly.com/" target=3D"_blank">http://blo=
g.atomly.com/</a> ...<br>









[ atomiq records : new york city : <a href=3D"tel:%2B1.347.692.8661" value=
=3D"+13476928661" target=3D"_blank">+1.347.692.8661</a> ...<br>[ e-mail <a =
href=3D"mailto:atomly-news-subscribe@atomly.com" target=3D"_blank">atomly-n=
ews-subscribe@atomly.com</a> for atomly info and updates ...</div>







<div><div>
<br><br><div class=3D"gmail_quote">On Thu, Aug 28, 2014 at 12:05 PM, Pedro =
Larroy <span dir=3D"ltr">&lt;<a href=3D"mailto:pedro.larroy.lists@gmail.com=
" target=3D"_blank">pedro.larroy.lists@gmail.com</a>&gt;</span> wrote:<br><=
blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px=
 #ccc solid;padding-left:1ex">









<div dir=3D"ltr">Hi<div><br></div><div>would it be interesting to include a=
 grouping iterator given a predicate and previous elements to get an iterab=
le of seq given an iterator?</div><div><br></div><div><br></div><div>The co=
de would be something like the following one.</div>









<div><br></div><div><br>Regards.</div><div><br></div><div>Pedro.</div><div>=
<br></div><div><br></div><div><br></div><div><div>=C2=A0 =C2=A0 import scal=
a.collection.mutable.ArrayBuffer</div><div>=C2=A0 =C2=A0=C2=A0</div><div>=
=C2=A0 =C2=A0 object GroupingIterator {</div>









<div>=C2=A0 =C2=A0=C2=A0</div><div>=C2=A0 =C2=A0 =C2=A0 /**</div><div>=C2=
=A0 =C2=A0 =C2=A0 =C2=A0* Create a new GroupingIterator with a grouping pre=
dicate.</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0*</div><div>=C2=A0 =C2=A0 =C2=
=A0 =C2=A0* @param it The original iterator</div><div>=C2=A0 =C2=A0 =C2=A0 =
=C2=A0* @param p Predicate controlling the grouping</div>









<div>=C2=A0 =C2=A0 =C2=A0 =C2=A0* @tparam A Type of elements iterated</div>=
<div>=C2=A0 =C2=A0 =C2=A0 =C2=A0* @return A new GroupingIterator</div><div>=
=C2=A0 =C2=A0 =C2=A0 =C2=A0*/</div><div>=C2=A0 =C2=A0 =C2=A0 def apply[A](i=
t: Iterator[A])(p: (A, IndexedSeq[A]) =3D&gt; Boolean): GroupingIterator[A]=
 =3D</div>









<div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 new GroupingIterator(it)(p)</div><div>=C2=
=A0 =C2=A0 }</div><div>=C2=A0 =C2=A0=C2=A0</div><div>=C2=A0 =C2=A0 /**</div=
><div>=C2=A0 =C2=A0 =C2=A0* Group elements in sequences of contiguous eleme=
nts that satisfy a predicate. The predicate</div><div>=C2=A0 =C2=A0 =C2=A0*=
 tests each single potential next element of the group with the help of the=
 elements grouped so far.</div>









<div>=C2=A0 =C2=A0 =C2=A0* If it returns true, the potential next element i=
s added to the group, otherwise</div><div>=C2=A0 =C2=A0 =C2=A0* a new group=
 is started with the potential next element as first element</div><div>=C2=
=A0 =C2=A0 =C2=A0*</div><div>=C2=A0 =C2=A0 =C2=A0* @param self The original=
 iterator</div>









<div>=C2=A0 =C2=A0 =C2=A0* @param p Predicate controlling the grouping</div=
><div>=C2=A0 =C2=A0 =C2=A0* @tparam A Type of elements iterated</div><div>=
=C2=A0 =C2=A0 =C2=A0*/</div><div>=C2=A0 =C2=A0 class GroupingIterator[+A](s=
elf: Iterator[A])(p: (A, IndexedSeq[A]) =3D&gt; Boolean) extends Iterator[I=
ndexedSeq[A]] {</div>









<div>=C2=A0 =C2=A0=C2=A0</div><div>=C2=A0 =C2=A0 =C2=A0 private[this] val s=
ource =3D self.buffered</div><div>=C2=A0 =C2=A0 =C2=A0 private[this] val bu=
ffer: ArrayBuffer[A] =3D ArrayBuffer()</div><div>=C2=A0 =C2=A0=C2=A0</div><=
div>=C2=A0 =C2=A0 =C2=A0 def hasNext: Boolean =3D source.hasNext</div><div>=
=C2=A0 =C2=A0=C2=A0</div>









<div>=C2=A0 =C2=A0 =C2=A0 def next(): IndexedSeq[A] =3D {</div><div>=C2=A0 =
=C2=A0 =C2=A0 =C2=A0 if (hasNext)</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 nextGroup()</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 else</div><div>=C2=A0=
 =C2=A0 =C2=A0 =C2=A0 =C2=A0 Iterator.empty.next()</div><div>=C2=A0 =C2=A0 =
=C2=A0 }</div><div>=C2=A0 =C2=A0=C2=A0</div><div>=C2=A0 =C2=A0 =C2=A0 priva=
te[this] def nextGroup(): IndexedSeq[A] =3D {</div>









<div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 assert(source.hasNext)</div><div>=C2=A0 =
=C2=A0=C2=A0</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 buffer.clear()</div><div=
>=C2=A0 =C2=A0 =C2=A0 =C2=A0 buffer +=3D source.next</div><div>=C2=A0 =C2=
=A0=C2=A0</div><div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 while (source.hasNext &amp;=
&amp; p(source.head, buffer)) {</div>









<div>=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 buffer +=3D source.next</div><div>=
=C2=A0 =C2=A0 =C2=A0 =C2=A0 }</div><div>=C2=A0 =C2=A0=C2=A0</div><div>=C2=
=A0 =C2=A0 =C2=A0 =C2=A0 buffer.toIndexedSeq</div><div>=C2=A0 =C2=A0 =C2=A0=
 }</div><div>=C2=A0 =C2=A0 }</div></div></div><span><font color=3D"#888888"=
>

<p></p>

-- <br>
You received this message because you are subscribed to the Google Groups &=
quot;scala-user&quot; group.<br>
To unsubscribe from this group and stop receiving emails from it, send an e=
mail to <a href=3D"mailto:scala-user+unsubscribe@googlegroups.com" target=
=3D"_blank">scala-user+unsubscribe@googlegroups.com</a>.<br>
For more options, visit <a href=3D"https://groups.google.com/d/optout" targ=
et=3D"_blank">https://groups.google.com/d/optout</a>.<br>
</font></span></blockquote></div><br></div></div></div><div><div>

<p></p>

-- <br>
You received this message because you are subscribed to the Google Groups &=
quot;scala-user&quot; group.<br>
To unsubscribe from this group and stop receiving emails from it, send an e=
mail to <a href=3D"mailto:scala-user+unsubscribe@googlegroups.com" target=
=3D"_blank">scala-user+unsubscribe@googlegroups.com</a>.<br>
For more options, visit <a href=3D"https://groups.google.com/d/optout" targ=
et=3D"_blank">https://groups.google.com/d/optout</a>.<br>
</div></div></blockquote></div><br></div>
</div></div></blockquote></div><br></div>

<p></p>

-- <br>
You received this message because you are subscribed to the Google Groups &=
quot;scala-user&quot; group.<br>
To unsubscribe from this group and stop receiving emails from it, send an e=
mail to <a href=3D"mailto:scala-user+unsubscribe@googlegroups.com" target=
=3D"_blank">scala-user+unsubscribe@googlegroups.com</a>.<br>
For more options, visit <a href=3D"https://groups.google.com/d/optout" targ=
et=3D"_blank">https://groups.google.com/d/optout</a>.<br>
</div></div></blockquote></div><br></div></div></div><div><div>

<p></p>

-- <br>
You received this message because you are subscribed to the Google Groups &=
quot;scala-user&quot; group.<br>
To unsubscribe from this group and stop receiving emails from it, send an e=
mail to <a href=3D"mailto:scala-user+unsubscribe@googlegroups.com" target=
=3D"_blank">scala-user+unsubscribe@googlegroups.com</a>.<br>
For more options, visit <a href=3D"https://groups.google.com/d/optout" targ=
et=3D"_blank">https://groups.google.com/d/optout</a>.<br>
</div></div></blockquote></div></div></div><br></div>
</blockquote></div><br></div>
</div></div></blockquote></div><br></div>

<p></p>

-- <br />
You received this message because you are subscribed to the Google Groups &=
quot;scala-user&quot; group.<br />
To unsubscribe from this group and stop receiving emails from it, send an e=
mail to <a href=3D"mailto:scala-user+unsubscribe@googlegroups.com">scala-us=
er+unsubscribe@googlegroups.com</a>.<br />
For more options, visit <a href=3D"https://groups.google.com/d/optout">http=
s://groups.google.com/d/optout</a>.<br />

--001a11c14f7eda93330501d9bdbd--
